<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sampling Tree Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            height: 90vh;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        
        .controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .tree-container {
            flex: 1;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            min-height: 400px;
        }
        
        #tree-svg {
            display: block;
            min-width: 100%;
            min-height: 100%;
        }
        
        /* èŠ‚ç‚¹æ ·å¼ */
        .node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .node:hover {
            filter: brightness(1.1);
        }
        
        .node circle {
            fill: #4CAF50;
            stroke: #2E7D32;
            stroke-width: 2px;
            transition: all 0.2s ease;
        }
        
        .node.root circle {
            fill: #FF9800;
            stroke: #F57C00;
        }
        
        .node.leaf circle {
            fill: #2196F3;
            stroke: #1976D2;
        }
        
        .node text {
            font-size: 11px;
            font-weight: 500;
            fill: #333;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }
        
        /* è¿æ¥çº¿æ ·å¼ */
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 1.5px;
            transition: all 0.2s ease;
        }
        
        .link.highlight {
            stroke: #FF5722;
            stroke-width: 2px;
        }
        
        .btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 12px;
        }
        
        .btn:hover {
            background: #1976D2;
        }
        
        /* å¢å¼ºçš„ Tooltip æ ·å¼ */
        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 400px;
            min-width: 250px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid #555;
        }
        
        .tooltip-header {
            font-size: 14px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #555;
        }
        
        .tooltip-section {
            margin-bottom: 10px;
        }
        
        .tooltip-label {
            font-weight: bold;
            color: #e74c3c;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 3px;
            display: block;
        }
        
        .tooltip-value {
            color: #ecf0f1;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            word-break: break-word;
            line-height: 1.4;
            background: rgba(255,255,255,0.1);
            padding: 4px 6px;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        
        .tooltip-text {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }
        
        .tooltip-tokens {
            max-height: 80px;
            overflow-y: auto;
            background: rgba(255,255,255,0.05);
            padding: 6px;
            border-radius: 4px;
            font-size: 10px;
        }
        
        /* ç¡®ä¿æ»šåŠ¨æ¡å¯è§ */
        .tree-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .tree-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .tree-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }
        
        .tree-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        /* Tooltip æ»šåŠ¨æ¡æ ·å¼ */
        .tooltip-text::-webkit-scrollbar,
        .tooltip-tokens::-webkit-scrollbar {
            width: 4px;
        }
        
        .tooltip-text::-webkit-scrollbar-track,
        .tooltip-tokens::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        
        .tooltip-text::-webkit-scrollbar-thumb,
        .tooltip-tokens::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>ğŸŒ³ Sampling Tree Visualization</h1>
    
    <div class="container">
        <div class="controls">
            <button class="btn" onclick="resetZoom()">é‡ç½®ç¼©æ”¾</button>
            <button class="btn" onclick="fitToContainer()">é€‚åº”çª—å£</button>
            <span style="margin-left: 20px; color: #666; font-size: 12px;">
                ğŸ’¡ å°†é¼ æ ‡æ‚¬åœåœ¨èŠ‚ç‚¹ä¸ŠæŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
            </span>
        </div>
        <div class="tree-container" id="tree-container">
            <svg id="tree-svg"></svg>
        </div>
    </div>

    <script>
        const treeData = {tree_json}
        let root = treeData.tree_data;
        const metaInfo = treeData.meta_info;
        
        // åŠ¨æ€è®¡ç®—å®¹å™¨å°ºå¯¸
        function getContainerDimensions() {
            const container = document.getElementById('tree-container');
            const rect = container.getBoundingClientRect();
            return {
                width: rect.width,
                height: rect.height
            };
        }
        
        // è®¡ç®—æ ‘çš„å®é™…éœ€è¦å°ºå¯¸
        function calculateTreeDimensions(root) {
            const nodeCount = root.descendants().length;
            const maxDepth = root.height;
            
            // æ ¹æ®èŠ‚ç‚¹æ•°é‡å’Œæ·±åº¦è®¡ç®—åˆé€‚çš„å°ºå¯¸
            const minWidth = Math.max(800, maxDepth * 250 + 400);
            const minHeight = Math.max(600, nodeCount * 40 + 200);
            
            return { width: minWidth, height: minHeight };
        }
        
        // åˆå§‹åŒ–SVGå°ºå¯¸
        function initializeSVG() {
            const containerDims = getContainerDimensions();
            const margin = {top: 40, right: 150, bottom: 40, left: 150};
            
            // ç¡®ä¿SVGè‡³å°‘å¡«æ»¡å®¹å™¨
            const width = Math.max(containerDims.width - margin.left - margin.right, 600);
            const height = Math.max(containerDims.height - margin.top - margin.bottom, 400);
            
            const svg = d3.select("#tree-svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
            
            return { svg, width, height, margin };
        }
        
        // é‡æ–°åˆå§‹åŒ–
        let { svg, width, height, margin } = initializeSVG();
        
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // ç¼©æ”¾å’Œæ‹–æ‹½
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        
        svg.call(zoom);
        
        // æ ‘å¸ƒå±€
        let treemap = d3.tree().size([height, width]);
        
        // åˆ›å»ºæ ¹èŠ‚ç‚¹ - æ‰€æœ‰èŠ‚ç‚¹éƒ½å±•å¼€
        root = d3.hierarchy(root, d => d.children);
        root.x0 = height / 2;
        root.y0 = 0;
        
        // åŠ¨æ€è°ƒæ•´SVGå°ºå¯¸
        function adjustSVGSize() {
            const treeDims = calculateTreeDimensions(root);
            const containerDims = getContainerDimensions();
            
            // ä½¿ç”¨è¾ƒå¤§çš„å°ºå¯¸ä»¥ç¡®ä¿æ ‘å®Œå…¨å¯è§
            const newWidth = Math.max(treeDims.width, containerDims.width - margin.left - margin.right);
            const newHeight = Math.max(treeDims.height, containerDims.height - margin.top - margin.bottom);
            
            svg.attr("width", newWidth + margin.left + margin.right)
               .attr("height", newHeight + margin.top + margin.bottom);
            
            // æ›´æ–°æ ‘å¸ƒå±€å°ºå¯¸
            treemap.size([newHeight, newWidth]);
            
            return { width: newWidth, height: newHeight };
        }
        
        // å¢å¼ºçš„ Tooltip
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
        
        // å¤„ç†ç‰¹æ®Šå­—ç¬¦æ˜¾ç¤º
        function formatTextForDisplay(text) {
            if (!text) return 'N/A';
            
            // å°†å„ç§è½¬ä¹‰å­—ç¬¦è½¬æ¢ä¸ºå¯è§å­—ç¬¦
            return text
                .replace(/\n/g, '\\n')      // æ¢è¡Œç¬¦æ˜¾ç¤ºä¸º \n
                .replace(/\t/g, '\\t')      // åˆ¶è¡¨ç¬¦æ˜¾ç¤ºä¸º \t
                .replace(/\r/g, '\\r')      // å›è½¦ç¬¦æ˜¾ç¤ºä¸º \r
                .replace(/\"/g, '\\"')      // åŒå¼•å·æ˜¾ç¤ºä¸º \"
                .replace(/\'/g, "\\'")      // å•å¼•å·æ˜¾ç¤ºä¸º \'
                .replace(/\\/g, '\\\\');    // åæ–œæ æ˜¾ç¤ºä¸º \\ï¼ˆæ³¨æ„ï¼šè¿™ä¸ªè¦æ”¾æœ€åï¼Œé¿å…å½±å“å‰é¢çš„æ›¿æ¢ï¼‰
        }
        
        // HTMLè½¬ä¹‰å‡½æ•°
        function escapeHtml(text) {
            if (!text) return 'N/A';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // æ ¼å¼åŒ– tooltip å†…å®¹ - ä½¿ç”¨å®‰å…¨çš„æ–‡æœ¬å¤„ç†
        function formatTooltipContent(d) {
            const data = d.data;
            
            // åˆ›å»ºtooltipå®¹å™¨
            const tooltipDiv = document.createElement('div');
            
            // åˆ›å»ºå„ä¸ªéƒ¨åˆ†
            const header = document.createElement('div');
            header.className = 'tooltip-header';
            header.textContent = data.name;
            tooltipDiv.appendChild(header);
            
            // æ·»åŠ å„ä¸ªä¿¡æ¯æ®µ
            const sections = [
                { label: 'Node ID', value: data.id },
                { label: 'Score', value: data.score },
                { label: 'Advantage', value: data.advantage },
                { label: 'Depth', value: data.depth },
                { label: 'Children Count', value: data.children_count }
            ];
            
            sections.forEach(section => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'tooltip-section';
                
                const label = document.createElement('span');
                label.className = 'tooltip-label';
                label.textContent = section.label;
                
                const value = document.createElement('div');
                value.className = 'tooltip-value';
                value.textContent = section.value;
                
                sectionDiv.appendChild(label);
                sectionDiv.appendChild(value);
                tooltipDiv.appendChild(sectionDiv);
            });
            
            // Full Text éƒ¨åˆ† - ç‰¹æ®Šå¤„ç†è½¬ä¹‰å­—ç¬¦
            const textSection = document.createElement('div');
            textSection.className = 'tooltip-section';
            
            const textLabel = document.createElement('span');
            textLabel.className = 'tooltip-label';
            textLabel.textContent = 'Full Text';
            
            const textValue = document.createElement('div');
            textValue.className = 'tooltip-text';
            // ä½¿ç”¨æ ¼å¼åŒ–å‡½æ•°å¤„ç†ç‰¹æ®Šå­—ç¬¦
            textValue.textContent = formatTextForDisplay(data.full_text);
            
            textSection.appendChild(textLabel);
            textSection.appendChild(textValue);
            tooltipDiv.appendChild(textSection);
            
            // Token Sequence éƒ¨åˆ†
            const tokenSection = document.createElement('div');
            tokenSection.className = 'tooltip-section';
            
            const tokenLabel = document.createElement('span');
            tokenLabel.className = 'tooltip-label';
            tokenLabel.textContent = 'Token Sequence';
            
            const tokenValue = document.createElement('div');
            tokenValue.className = 'tooltip-tokens';
            tokenValue.textContent = JSON.stringify(data.token_sequence, null, 2);
            
            tokenSection.appendChild(tokenLabel);
            tokenSection.appendChild(tokenValue);
            tooltipDiv.appendChild(tokenSection);
            
            return tooltipDiv.innerHTML;
        }
        
        // æ™ºèƒ½è®¡ç®—tooltipä½ç½®
        function calculateTooltipPosition(event) {
            const tooltip = document.querySelector('.tooltip');
            if (!tooltip) return { left: event.pageX + 15, top: event.pageY - 15 };
            
            // è·å–tooltipçš„å°ºå¯¸ï¼ˆéœ€è¦å…ˆè®¾ç½®å†…å®¹ï¼‰
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width || 300; // é»˜è®¤å®½åº¦
            const tooltipHeight = tooltipRect.height || 400; // é»˜è®¤é«˜åº¦
            
            // è·å–è§†çª—å°ºå¯¸
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // é¼ æ ‡ç›¸å¯¹äºè§†çª—çš„ä½ç½®
            const mouseX = event.clientX;
            const mouseY = event.clientY;
            
            // è®¡ç®—åˆå§‹ä½ç½®ï¼ˆé¼ æ ‡å³ä¸‹æ–¹ï¼‰
            let left = event.pageX + 15;
            let top = event.pageY - 15;
            
            // æ£€æŸ¥å³è¾¹ç•Œ - å¦‚æœè¶…å‡ºå³è¾¹ï¼Œæ˜¾ç¤ºåœ¨é¼ æ ‡å·¦ä¾§
            if (mouseX + tooltipWidth + 15 > viewportWidth) {
                left = event.pageX - tooltipWidth - 15;
            }
            
            // æ£€æŸ¥ä¸‹è¾¹ç•Œ - å¦‚æœè¶…å‡ºä¸‹è¾¹ï¼Œè°ƒæ•´åˆ°ä¸Šæ–¹
            if (mouseY + tooltipHeight + 15 > viewportHeight) {
                top = event.pageY - tooltipHeight - 15;
            }
            
            // æ£€æŸ¥ä¸Šè¾¹ç•Œ - å¦‚æœè¿˜æ˜¯è¶…å‡ºä¸Šè¾¹ï¼Œå¼ºåˆ¶åœ¨è§†çª—å†…
            if (top < scrollTop + 10) {
                top = scrollTop + 10;
            }
            
            // æ£€æŸ¥å·¦è¾¹ç•Œ - å¦‚æœè¶…å‡ºå·¦è¾¹ï¼Œå¼ºåˆ¶åœ¨è§†çª—å†…
            if (left < scrollLeft + 10) {
                left = scrollLeft + 10;
            }
            
            return { left, top };
        }
        
        // æ›´æ–°æ ‘
        function update(source) {
            // è°ƒæ•´SVGå°ºå¯¸
            const dims = adjustSVGSize();
            
            const treeData = treemap(root);
            const nodes = treeData.descendants();
            const links = treeData.descendants().slice(1);
            
            // æ ‡å‡†åŒ–å›ºå®šæ·±åº¦
            nodes.forEach(d => { d.y = d.depth * 220; });
            
            // æ›´æ–°èŠ‚ç‚¹
            const node = g.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));
            
            // è¿›å…¥æ–°èŠ‚ç‚¹
            const nodeEnter = node.enter().append('g')
                .attr('class', d => {
                    let classes = 'node';
                    if (d.data.is_root) classes += ' root';
                    if (d.data.is_leaf) classes += ' leaf';
                    return classes;
                })
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .on('mouseover', (event, d) => {
                    // æ˜¾ç¤ºå¢å¼ºçš„ tooltip
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(formatTooltipContent(d));
                    
                    // æ™ºèƒ½å®šä½tooltip
                    const position = calculateTooltipPosition(event);
                    tooltip.style("left", position.left + "px")
                           .style("top", position.top + "px");
                    
                    // é«˜äº®å½“å‰èŠ‚ç‚¹çš„è·¯å¾„
                    highlightPath(d);
                })
                .on('mousemove', (event, d) => {
                    // å®æ—¶è°ƒæ•´tooltipä½ç½®
                    const position = calculateTooltipPosition(event);
                    tooltip.style("left", position.left + "px")
                           .style("top", position.top + "px");
                })
                .on('mouseout', () => {
                    // éšè— tooltip
                    tooltip.transition().duration(300).style("opacity", 0);
                    
                    // ç§»é™¤é«˜äº®
                    removeHighlight();
                });
            
            // æ·»åŠ åœ†åœˆ
            nodeEnter.append('circle')
                .attr('r', 1e-6);
            
            // æ›´æ–°èŠ‚ç‚¹
            const nodeUpdate = nodeEnter.merge(node);
            
            nodeUpdate.transition()
                .duration(750)
                .attr("transform", d => `translate(${d.y},${d.x})`);
            
            nodeUpdate.select('circle')
                .transition()
                .duration(750)
                .attr('r', 10)
                .style("fill", d => {
                    if (d.data.is_root) return "#FF9800";
                    if (d.data.is_leaf) return "#2196F3";
                    return "#4CAF50";
                });
            
            nodeUpdate.select('text')
                .transition()
                .duration(750)
                .style("fill-opacity", 1);
            
            // ç§»é™¤èŠ‚ç‚¹
            const nodeExit = node.exit().transition()
                .duration(750)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();
            
            nodeExit.select('circle')
                .attr('r', 1e-6);
            
            nodeExit.select('text')
                .style('fill-opacity', 1e-6);
            
            // æ›´æ–°è¿æ¥çº¿
            const link = g.selectAll('path.link')
                .data(links, d => d.id);
            
            const linkEnter = link.enter().insert('path', "g")
                .attr("class", "link")
                .attr('d', d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal(o, o);
                });
            
            const linkUpdate = linkEnter.merge(link);
            
            linkUpdate.transition()
                .duration(750)
                .attr('d', d => diagonal(d, d.parent));
            
            link.exit().transition()
                .duration(750)
                .attr('d', d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal(o, o);
                })
                .remove();
            
            // å­˜å‚¨æ—§ä½ç½®
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        
        // é«˜äº®è·¯å¾„
        function highlightPath(node) {
            // é«˜äº®ä»æ ¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„
            const pathNodes = [];
            let current = node;
            while (current) {
                pathNodes.push(current);
                current = current.parent;
            }
            
            // é«˜äº®è¿æ¥çº¿
            g.selectAll('path.link')
                .classed('highlight', d => pathNodes.includes(d));
            
            // é«˜äº®èŠ‚ç‚¹
            g.selectAll('g.node circle')
                .style('stroke-width', d => pathNodes.includes(d) ? '3px' : '2px')
                .style('filter', d => pathNodes.includes(d) ? 'drop-shadow(0 0 6px rgba(255,87,34,0.6))' : 'none');
        }
        
        // ç§»é™¤é«˜äº®
        function removeHighlight() {
            g.selectAll('path.link').classed('highlight', false);
            g.selectAll('g.node circle')
                .style('stroke-width', '2px')
                .style('filter', 'none');
        }
        
        // åˆ›å»ºè¿æ¥çº¿
        function diagonal(s, d) {
            const path = `M ${s.y} ${s.x}
                        C ${(s.y + d.y) / 2} ${s.x},
                          ${(s.y + d.y) / 2} ${d.x},
                          ${d.y} ${d.x}`;
            return path;
        }
        
        // æ§åˆ¶å‡½æ•°
        window.resetZoom = function() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
        };
        
        // é€‚åº”çª—å£å¤§å°
        window.fitToContainer = function() {
            const containerDims = getContainerDimensions();
            const bounds = g.node().getBBox();
            
            if (bounds.width === 0 || bounds.height === 0) return;
            
            const fullWidth = bounds.width + margin.left + margin.right;
            const fullHeight = bounds.height + margin.top + margin.bottom;
            
            const midX = bounds.x + bounds.width / 2;
            const midY = bounds.y + bounds.height / 2;
            
            const scale = 0.85 / Math.max(fullWidth / containerDims.width, fullHeight / containerDims.height);
            const translate = [containerDims.width / 2 - scale * midX, containerDims.height / 2 - scale * midY];
            
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        };
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´
        window.addEventListener('resize', () => {
            setTimeout(() => {
                const newDims = initializeSVG();
                svg = newDims.svg;
                width = newDims.width;
                height = newDims.height;
                margin = newDims.margin;
                treemap.size([height, width]);
                update(root);
            }, 100);
        });
        
        // åˆå§‹åŒ–
        let i = 0;
        update(root);
        
        // åˆå§‹é€‚åº”çª—å£
        setTimeout(() => {
            fitToContainer();
        }, 1000);
    </script>
</body>
</html>