<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sampling Tree Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            height: 90vh;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        
        .controls {
            margin-bottom: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .tree-container {
            flex: 1;
            overflow: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            min-height: 400px;
        }
        
        #tree-svg {
            display: block;
            min-width: 100%;
            min-height: 100%;
        }
        
        /* èŠ‚ç‚¹æ ·å¼ */
        .node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .node:hover {
            filter: brightness(1.1);
        }
        
        .node circle {
            fill: #4CAF50;
            stroke: #2E7D32;
            stroke-width: 2px;
            transition: all 0.2s ease;
        }
        
        .node.root circle {
            fill: #FF9800;
            stroke: #F57C00;
        }
        
        .node.leaf circle {
            fill: #2196F3;
            stroke: #1976D2;
        }
        
        .node.active circle {
            stroke: #FF5722;
            stroke-width: 3px;
            filter: drop-shadow(0 0 8px rgba(255,87,34,0.6));
        }
        
        .node text {
            font-size: 11px;
            font-weight: 500;
            fill: #333;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }
        
        /* è¿æ¥çº¿æ ·å¼ */
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 1.5px;
            transition: all 0.2s ease;
        }
        
        .link.highlight {
            stroke: #FF5722;
            stroke-width: 2px;
        }
        
        .btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 12px;
        }
        
        .btn:hover {
            background: #1976D2;
        }
        
        /* ä¿®æ”¹åçš„ Tooltip æ ·å¼ - ç°åœ¨æ˜¯ç»å¯¹å®šä½ç›¸å¯¹äºæ ‘å®¹å™¨ */
        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            max-width: 350px;
            min-width: 280px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            border: 1px solid #555;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            transform: translateY(-10px);
        }
        
        .tooltip.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        
        .tooltip-header {
            font-size: 14px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tooltip-close {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .tooltip-close:hover {
            background: #c0392b;
        }
        
        .tooltip-section {
            margin-bottom: 10px;
        }
        
        .tooltip-label {
            font-weight: bold;
            color: #e74c3c;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 3px;
            display: block;
        }
        
        .tooltip-value {
            color: #ecf0f1;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            word-break: break-word;
            line-height: 1.4;
            background: rgba(255,255,255,0.1);
            padding: 4px 6px;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        
        .tooltip-text {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }
        
        .tooltip-tokens {
            max-height: 80px;
            overflow-y: auto;
            background: rgba(255,255,255,0.05);
            padding: 6px;
            border-radius: 4px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        
        /* ç¡®ä¿æ»šåŠ¨æ¡å¯è§ */
        .tree-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .tree-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .tree-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }
        
        .tree-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        /* Tooltip æ»šåŠ¨æ¡æ ·å¼ */
        .tooltip-text::-webkit-scrollbar,
        .tooltip-tokens::-webkit-scrollbar {
            width: 4px;
        }
        
        .tooltip-text::-webkit-scrollbar-track,
        .tooltip-tokens::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
        
        .tooltip-text::-webkit-scrollbar-thumb,
        .tooltip-tokens::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>ğŸŒ³ Sampling Tree Visualization</h1>
    
    <div class="container">
        <div class="controls">
            <button class="btn" onclick="resetZoom()">é‡ç½®ç¼©æ”¾</button>
            <button class="btn" onclick="fitToContainer()">é€‚åº”çª—å£</button>
            <button class="btn" onclick="closeTooltip()">å…³é—­ä¿¡æ¯é¢æ¿</button>
            <span style="margin-left: 20px; color: #666; font-size: 12px;">
                ğŸ’¡ ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
            </span>
        </div>
        <div class="tree-container" id="tree-container">
            <svg id="tree-svg"></svg>
        </div>
    </div>

    <script>
        // ç¤ºä¾‹æ•°æ®ç»“æ„
        const treeData = {tree_json};
        
        let root = treeData.tree_data;
        const metaInfo = treeData.meta_info;
        let currentActiveNode = null; // è·Ÿè¸ªå½“å‰æ´»è·ƒçš„èŠ‚ç‚¹
        
        // åŠ¨æ€è®¡ç®—å®¹å™¨å°ºå¯¸
        function getContainerDimensions() {
            const container = document.getElementById('tree-container');
            const rect = container.getBoundingClientRect();
            return {
                width: rect.width,
                height: rect.height
            };
        }
        
        // è®¡ç®—æ ‘çš„å®é™…éœ€è¦å°ºå¯¸
        function calculateTreeDimensions(root) {
            const nodeCount = root.descendants().length;
            const maxDepth = root.height;
            
            // æ ¹æ®èŠ‚ç‚¹æ•°é‡å’Œæ·±åº¦è®¡ç®—åˆé€‚çš„å°ºå¯¸
            const minWidth = Math.max(800, maxDepth * 250 + 400);
            const minHeight = Math.max(600, nodeCount * 40 + 200);
            
            return { width: minWidth, height: minHeight };
        }
        
        // åˆå§‹åŒ–SVGå°ºå¯¸
        function initializeSVG() {
            const containerDims = getContainerDimensions();
            const margin = {top: 40, right: 150, bottom: 40, left: 150};
            
            // ç¡®ä¿SVGè‡³å°‘å¡«æ»¡å®¹å™¨
            const width = Math.max(containerDims.width - margin.left - margin.right, 600);
            const height = Math.max(containerDims.height - margin.top - margin.bottom, 400);
            
            const svg = d3.select("#tree-svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
            
            return { svg, width, height, margin };
        }
        
        // é‡æ–°åˆå§‹åŒ–
        let { svg, width, height, margin } = initializeSVG();
        
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // ç¼©æ”¾å’Œæ‹–æ‹½
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
                // å¦‚æœæœ‰æ¿€æ´»çš„tooltipï¼Œéœ€è¦æ›´æ–°å…¶ä½ç½®
                if (currentActiveNode) {
                    updateTooltipPosition(currentActiveNode);
                }
            });
        
        svg.call(zoom);
        
        // æ ‘å¸ƒå±€
        let treemap = d3.tree().size([height, width]);
        
        // åˆ›å»ºæ ¹èŠ‚ç‚¹ - æ‰€æœ‰èŠ‚ç‚¹éƒ½å±•å¼€
        root = d3.hierarchy(root, d => d.children);
        root.x0 = height / 2;
        root.y0 = 0;
        
        // åŠ¨æ€è°ƒæ•´SVGå°ºå¯¸
        function adjustSVGSize() {
            const treeDims = calculateTreeDimensions(root);
            const containerDims = getContainerDimensions();
            
            // ä½¿ç”¨è¾ƒå¤§çš„å°ºå¯¸ä»¥ç¡®ä¿æ ‘å®Œå…¨å¯è§
            const newWidth = Math.max(treeDims.width, containerDims.width - margin.left - margin.right);
            const newHeight = Math.max(treeDims.height, containerDims.height - margin.top - margin.bottom);
            
            svg.attr("width", newWidth + margin.left + margin.right)
               .attr("height", newHeight + margin.top + margin.bottom);
            
            // æ›´æ–°æ ‘å¸ƒå±€å°ºå¯¸
            treemap.size([newHeight, newWidth]);
            
            return { width: newWidth, height: newHeight };
        }
        
        // åœ¨æ ‘å®¹å™¨å†…åˆ›å»ºtooltip
        const tooltip = d3.select("#tree-container").append("div")
            .attr("class", "tooltip");
        
        // ä¿®æ”¹åçš„æ–‡æœ¬æ ¼å¼åŒ–å‡½æ•° - è®©è½¬ä¹‰å­—ç¬¦å¯è§ä½†ä¸æ‰§è¡Œ
        function formatTextForDisplay(text) {
            if (!text) return 'N/A';
            
            // å¦‚æœæ–‡æœ¬ä¸­åŒ…å«çš„æ˜¯å®é™…çš„æ¢è¡Œç¬¦ã€åˆ¶è¡¨ç¬¦ç­‰ï¼Œå°†å®ƒä»¬è½¬æ¢ä¸ºå¯è§çš„è½¬ä¹‰å­—ç¬¦
            // å¦‚æœæ–‡æœ¬ä¸­å·²ç»æ˜¯ \n è¿™æ ·çš„å­—ç¬¦ä¸²ï¼Œåˆ™ä¿æŒä¸å˜
            return text
                .replace(/\\/g, '\\\\')
                .replace(/\n/g, '\\n')         // æ¢è¡Œç¬¦æ˜¾ç¤ºä¸º \n
                .replace(/\t/g, '\\t')         // åˆ¶è¡¨ç¬¦æ˜¾ç¤ºä¸º \t
                .replace(/\r/g, '\\r')        // å›è½¦ç¬¦æ˜¾ç¤ºä¸º \r
        }

        // æ ¼å¼åŒ– tooltip å†…å®¹ - ç‚¹å‡»ç‰ˆæœ¬
        function formatTooltipContent(d) {
            const data = d.data;
            
            // åˆ›å»ºtooltipå®¹å™¨
            const tooltipDiv = document.createElement('div');
            
            // åˆ›å»ºheaderéƒ¨åˆ†ï¼ŒåŒ…å«å…³é—­æŒ‰é’®
            const header = document.createElement('div');
            header.className = 'tooltip-header';
            
            const title = document.createElement('span');
            title.textContent = data.name;
            
            const closeButton = document.createElement('button');
            closeButton.className = 'tooltip-close';
            closeButton.innerHTML = 'Ã—';
            closeButton.type = 'button';
            // ç›´æ¥ç»‘å®šäº‹ä»¶å¤„ç†å™¨
            closeButton.addEventListener('click', function(e) {
                e.stopPropagation();
                closeTooltip();
            });
            
            header.appendChild(title);
            header.appendChild(closeButton);
            tooltipDiv.appendChild(header);
            
            // æ·»åŠ å„ä¸ªä¿¡æ¯æ®µ
            const sections = [
                { label: 'Node ID', value: data.id },
                { label: 'Score', value: data.score },
                { label: 'Advantage', value: data.advantage },
                { label: 'Depth', value: data.depth },
                { label: 'Children Count', value: data.children_count }
            ];
            
            sections.forEach(section => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'tooltip-section';
                
                const label = document.createElement('span');
                label.className = 'tooltip-label';
                label.textContent = section.label;
                
                const value = document.createElement('div');
                value.className = 'tooltip-value';
                value.textContent = section.value;
                
                sectionDiv.appendChild(label);
                sectionDiv.appendChild(value);
                tooltipDiv.appendChild(sectionDiv);
            });
            
            // Full Text éƒ¨åˆ† - ä½¿ç”¨ä¿®æ”¹åçš„æ ¼å¼åŒ–å‡½æ•°
            const textSection = document.createElement('div');
            textSection.className = 'tooltip-section';
            
            const textLabel = document.createElement('span');
            textLabel.className = 'tooltip-label';
            textLabel.textContent = 'Full Text';
            
            const textValue = document.createElement('div');
            textValue.className = 'tooltip-text';
            // ä½¿ç”¨ä¿®æ”¹åçš„æ ¼å¼åŒ–å‡½æ•°
            textValue.textContent = formatTextForDisplay(data.full_text);
            
            textSection.appendChild(textLabel);
            textSection.appendChild(textValue);
            tooltipDiv.appendChild(textSection);
            
            // Token Sequence éƒ¨åˆ†
            const tokenSection = document.createElement('div');
            tokenSection.className = 'tooltip-section';
            
            const tokenLabel = document.createElement('span');
            tokenLabel.className = 'tooltip-label';
            tokenLabel.textContent = 'Token Sequence';
            
            const tokenValue = document.createElement('div');
            tokenValue.className = 'tooltip-tokens';
            tokenValue.textContent = JSON.stringify(data.token_sequence, null, 2);
            
            tokenSection.appendChild(tokenLabel);
            tokenSection.appendChild(tokenValue);
            tooltipDiv.appendChild(tokenSection);
            
            return tooltipDiv;
        }
        
        // è·å–èŠ‚ç‚¹åœ¨å®¹å™¨ä¸­çš„å®é™…ä½ç½®
        function getNodePosition(d) {
            // è·å–å½“å‰çš„ç¼©æ”¾å˜æ¢
            const transform = d3.zoomTransform(svg.node());
            
            // è®¡ç®—èŠ‚ç‚¹åœ¨å˜æ¢åçš„ä½ç½®
            const x = (d.y + margin.left) * transform.k + transform.x;
            const y = (d.x + margin.top) * transform.k + transform.y;
            
            return { x, y };
        }
        
        // è®¡ç®—tooltipçš„æœ€ä½³ä½ç½®
        function calculateTooltipPosition(nodePos, tooltipWidth, tooltipHeight) {
            const container = document.getElementById('tree-container');
            const containerRect = container.getBoundingClientRect();
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            let x, y;
            const offset = 15; // è·ç¦»èŠ‚ç‚¹çš„åç§»é‡
            
            // é»˜è®¤ä½ç½®ï¼šèŠ‚ç‚¹å³ä¾§
            x = nodePos.x + offset;
            y = nodePos.y - tooltipHeight / 2;
            
            // æ£€æŸ¥å³ä¾§æ˜¯å¦è¶…å‡ºè¾¹ç•Œ
            if (x + tooltipWidth > containerWidth) {
                // å°è¯•å·¦ä¾§
                x = nodePos.x - tooltipWidth - offset;
            }
            
            // æ£€æŸ¥å·¦ä¾§æ˜¯å¦è¶…å‡ºè¾¹ç•Œ
            if (x < 0) {
                // å¦‚æœå·¦å³éƒ½ä¸è¡Œï¼Œæ”¾åœ¨èŠ‚ç‚¹ä¸‹æ–¹
                x = nodePos.x - tooltipWidth / 2;
                y = nodePos.y + offset;
                
                // å¦‚æœä¸‹æ–¹ä¹Ÿè¶…å‡ºï¼Œæ”¾åœ¨ä¸Šæ–¹
                if (y + tooltipHeight > containerHeight) {
                    y = nodePos.y - tooltipHeight - offset;
                }
            }
            
            // æœ€ç»ˆè¾¹ç•Œæ£€æŸ¥
            x = Math.max(5, Math.min(x, containerWidth - tooltipWidth - 5));
            y = Math.max(5, Math.min(y, containerHeight - tooltipHeight - 5));
            
            return { x, y };
        }
        
        // æ›´æ–°tooltipä½ç½®
        function updateTooltipPosition(d) {
            if (!tooltip.classed("show")) return;
            
            const nodePos = getNodePosition(d);
            const tooltipNode = tooltip.node();
            const tooltipRect = tooltipNode.getBoundingClientRect();
            
            const position = calculateTooltipPosition(
                nodePos, 
                tooltipRect.width || 350, 
                tooltipRect.height || 400
            );
            
            tooltip.style("left", position.x + "px")
                   .style("top", position.y + "px");
        }
        
        // æ˜¾ç¤ºtooltip
        function showTooltip(d, event) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ™å…³é—­tooltip
            if (currentActiveNode === d) {
                closeTooltip();
                return;
            }
            
            // å…³é—­ä¹‹å‰çš„tooltipå¹¶ç§»é™¤ä¹‹å‰çš„é«˜äº®
            if (currentActiveNode) {
                removeActiveState(currentActiveNode);
            }
            
            // è®¾ç½®æ–°çš„æ´»è·ƒèŠ‚ç‚¹
            currentActiveNode = d;
            
            // æ·»åŠ æ´»è·ƒçŠ¶æ€
            addActiveState(d);
            
            // åˆ›å»ºtooltipå†…å®¹å¹¶ç›´æ¥æ·»åŠ åˆ°DOM
            const tooltipContent = formatTooltipContent(d);
            tooltip.node().innerHTML = '';
            tooltip.node().appendChild(tooltipContent);
            
            // æ˜¾ç¤ºtooltipï¼ˆå…ˆæ˜¾ç¤ºä»¥è·å–å°ºå¯¸ï¼‰
            tooltip.classed("show", true);
            
            // è®¡ç®—å¹¶è®¾ç½®tooltipä½ç½®
            setTimeout(() => {
                updateTooltipPosition(d);
            }, 0);
            
            // é«˜äº®è·¯å¾„
            highlightPath(d);
        }
        
        // å…³é—­tooltip
        function closeTooltip() {
            tooltip.classed("show", false);
            
            if (currentActiveNode) {
                removeActiveState(currentActiveNode);
                currentActiveNode = null;
            }
            
            // ç§»é™¤é«˜äº®
            removeHighlight();
        }
        
        // æ·»åŠ æ´»è·ƒçŠ¶æ€
        function addActiveState(node) {
            g.selectAll('g.node')
                .classed('active', d => d === node);
        }
        
        // ç§»é™¤æ´»è·ƒçŠ¶æ€
        function removeActiveState(node) {
            g.selectAll('g.node')
                .classed('active', false);
        }
        
        // æ›´æ–°æ ‘
        function update(source) {
            // è°ƒæ•´SVGå°ºå¯¸
            const dims = adjustSVGSize();
            
            const treeData = treemap(root);
            const nodes = treeData.descendants();
            const links = treeData.descendants().slice(1);
            
            // æ ‡å‡†åŒ–å›ºå®šæ·±åº¦
            nodes.forEach(d => { d.y = d.depth * 220; });
            
            // æ›´æ–°èŠ‚ç‚¹
            const node = g.selectAll('g.node')
                .data(nodes, d => d.id || (d.id = ++i));
            
            // è¿›å…¥æ–°èŠ‚ç‚¹
            const nodeEnter = node.enter().append('g')
                .attr('class', d => {
                    let classes = 'node';
                    if (d.data.is_root) classes += ' root';
                    if (d.data.is_leaf) classes += ' leaf';
                    return classes;
                })
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .on('click', (event, d) => {
                    // é˜»æ­¢äº‹ä»¶å†’æ³¡
                    event.stopPropagation();
                    // æ˜¾ç¤º/éšè— tooltip
                    showTooltip(d, event);
                });
            
            // æ·»åŠ åœ†åœˆ
            nodeEnter.append('circle')
                .attr('r', 1e-6);
            
            // æ›´æ–°èŠ‚ç‚¹
            const nodeUpdate = nodeEnter.merge(node);
            
            nodeUpdate.transition()
                .duration(750)
                .attr("transform", d => `translate(${d.y},${d.x})`);
            
            nodeUpdate.select('circle')
                .transition()
                .duration(750)
                .attr('r', 10)
                .style("fill", d => {
                    if (d.data.is_root) return "#FF9800";
                    if (d.data.is_leaf) return "#2196F3";
                    return "#4CAF50";
                });
            
            nodeUpdate.select('text')
                .transition()
                .duration(750)
                .style("fill-opacity", 1);
            
            // ç§»é™¤èŠ‚ç‚¹
            const nodeExit = node.exit().transition()
                .duration(750)
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .remove();
            
            nodeExit.select('circle')
                .attr('r', 1e-6);
            
            nodeExit.select('text')
                .style('fill-opacity', 1e-6);
            
            // æ›´æ–°è¿æ¥çº¿
            const link = g.selectAll('path.link')
                .data(links, d => d.id);
            
            const linkEnter = link.enter().insert('path', "g")
                .attr("class", "link")
                .attr('d', d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal(o, o);
                });
            
            const linkUpdate = linkEnter.merge(link);
            
            linkUpdate.transition()
                .duration(750)
                .attr('d', d => diagonal(d, d.parent));
            
            link.exit().transition()
                .duration(750)
                .attr('d', d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal(o, o);
                })
                .remove();
            
            // å­˜å‚¨æ—§ä½ç½®
            nodes.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        
        // é«˜äº®è·¯å¾„
        function highlightPath(node) {
            // é«˜äº®ä»æ ¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„
            const pathNodes = [];
            let current = node;
            while (current) {
                pathNodes.push(current);
                current = current.parent;
            }
            
            // é«˜äº®è¿æ¥çº¿
            g.selectAll('path.link')
                .classed('highlight', d => pathNodes.includes(d));
        }
        
        // ç§»é™¤é«˜äº®
        function removeHighlight() {
            g.selectAll('path.link').classed('highlight', false);
        }
        
        // åˆ›å»ºè¿æ¥çº¿
        function diagonal(s, d) {
            const path = `M ${s.y} ${s.x}
                        C ${(s.y + d.y) / 2} ${s.x},
                          ${(s.y + d.y) / 2} ${d.x},
                          ${d.y} ${d.x}`;
            return path;
        }
        
        // æ§åˆ¶å‡½æ•°
        window.resetZoom = function() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
        };
        
        // é€‚åº”çª—å£å¤§å°
        window.fitToContainer = function() {
            const containerDims = getContainerDimensions();
            const bounds = g.node().getBBox();
            
            if (bounds.width === 0 || bounds.height === 0) return;
            
            const fullWidth = bounds.width + margin.left + margin.right;
            const fullHeight = bounds.height + margin.top + margin.bottom;
            
            const midX = bounds.x + bounds.width / 2;
            const midY = bounds.y + bounds.height / 2;
            
            const scale = 0.85 / Math.max(fullWidth / containerDims.width, fullHeight / containerDims.height);
            const translate = [containerDims.width / 2 - scale * midX, containerDims.height / 2 - scale * midY];
            
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        };
        
        // å…³é—­tooltipçš„å…¨å±€å‡½æ•°
        window.closeTooltip = closeTooltip;
        
        // ç‚¹å‡»ç©ºç™½åŒºåŸŸå…³é—­tooltip
        document.addEventListener('click', (event) => {
            // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯tooltipå†…éƒ¨ï¼Œåˆ™å…³é—­tooltip
            if (!event.target.closest('.tooltip') && !event.target.closest('.node')) {
                closeTooltip();
            }
        });
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´
        window.addEventListener('resize', () => {
            setTimeout(() => {
                const newDims = initializeSVG();
                svg = newDims.svg;
                width = newDims.width;
                height = newDims.height;
                margin = newDims.margin;
                treemap.size([height, width]);
                update(root);
                
                // å¦‚æœæœ‰æ´»è·ƒçš„tooltipï¼Œæ›´æ–°å…¶ä½ç½®
                if (currentActiveNode) {
                    updateTooltipPosition(currentActiveNode);
                }
            }, 100);
        });
        
        // åˆå§‹åŒ–
        let i = 0;
        update(root);
        
        // åˆå§‹é€‚åº”çª—å£
        setTimeout(() => {
            fitToContainer();
        }, 1000);
    </script>
</body>
</html>